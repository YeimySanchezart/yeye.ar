<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no, shrink-to-fit=no"
    />
    <!-- Prevent caching for development -->
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <!-- Mobile app capabilities -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="theme-color" content="#000000" />
    <!-- Camera permissions hint -->
    <meta http-equiv="Permissions-Policy" content="camera=*" />
    <title>Paramo - AR Experience</title>
    <script src="https://cdn.jsdelivr.net/npm/aframe@1.6.0/dist/aframe-master.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <style>
      /* === GLOBAL STYLES === */
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        /* === PERFORMANCE OPTIMIZATIONS === */
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;

        /* === USER INTERACTION PREVENTION === */
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
        /* Ensure full viewport coverage */
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      a-scene {
        /* Ensure scene covers full viewport */
        width: 100% !important;
        height: 100% !important;
      }
      .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 1000;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 10px;
      }
      .error {
        position: fixed;
        top: 10px;
        left: 10px;
        right: 10px;
        background: #ff4444;
        color: white;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
      }
      .hidden {
        display: none;
      }
      .footer {
        position: fixed;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 9999;
        text-align: center;
        display: none; /* Hide the footer */
      }
      .footer a {
        display: inline-block;
        color: white;
        text-decoration: none;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px 16px;
        border-radius: 20px;
        font-size: 14px;
        font-weight: normal;
        border: 1px solid rgba(255, 255, 255, 0.4);
        transition: background-color 0.3s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        pointer-events: none; /* Disable interaction */
        opacity: 0.5; /* Make it visually disabled */
      }
      .footer a:hover {
        background: rgba(0, 0, 0, 0.95);
        border-color: rgba(255, 255, 255, 0.6);
      }

      /* Mobile adjustments */
      @media (max-width: 768px) {
        .footer {
          bottom: 80px;
        }
        .footer a {
          padding: 12px 18px;
          font-size: 15px;
        }
      }

      /* Hide MindAR default UI elements */
      .mindar-ui-loading,
      .mindar-ui-scanning,
      .mindar-ui-error {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="loading" class="loading">
      <h2>Loading Paramo...</h2>
      <p>Point your camera at the target image</p>
    </div>

    <div id="error" class="error hidden"></div>

    <!-- Background ambient audio for the AR experience -->
    <audio id="ambient-audio" preload="auto" loop>
      <source src="assets/soothing-river-flow-372456.mp3" type="audio/mpeg" />
    </audio>

    <a-scene
      id="ar-scene"
      mindar-image="imageTargetSrc: ./target.mind; autoStart: true; uiLoading: no; uiScanning: no; uiError: no; filterMinCF: 0.1; filterBeta: 0.001; warmupTolerance: 5; missTolerance: 5"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
      renderer="alpha: true; antialias: true; colorManagement: true; physicallyCorrectLights: true; precision: highp; powerPreference: high-performance"
      style="position: fixed; top: 0; left: 0; width: 100%; height: 100%"
      embedded
    >
      <a-assets id="assets">
        <!-- Assets will be loaded dynamically -->
      </a-assets>

      <a-light type="ambient" color="#ffffff" intensity="0.6"></a-light>

      <a-entity
        id="target-root"
        mindar-image-target="targetIndex: 0"
        animation-mixer=""
        tracking-stabilizer="enabled: true; lockDistance: 0.5; lockTransitionZone: 0.15; consistencyFrames: 4; maxJumpDistance: 0.03; stabilityMemory: 20"

      >
        <!-- AR content will be added here -->
      </a-entity>

      <a-camera
        position="0 0 0"
        look-controls="enabled: false"
        cursor="rayOrigin: mouse"
        wasd-controls="enabled: false"
      ></a-camera>
    </a-scene>

    <div class="footer" id="footer">
      <a href="https://yeimysanchez.com/" id="about-link" target="_blank"
        >About this artwork</a
      >
    </div>

    <script>
      // ========================================
      // A-FRAME COMPONENTS
      // ========================================

      // Chroma key component with optional background masking
      AFRAME.registerComponent("chroma-key", {
        schema: {
          color: { type: "color", default: "#000000" },
          threshold: { type: "number", default: 0.15 },
          smoothing: { type: "number", default: 0.1 },
          backgroundMask: { type: "boolean", default: false },
          bgScaleX: { type: "number", default: 1.1625 }, // Background image X scale
          bgScaleY: { type: "number", default: 1.5 }, // Background image Y scale
        },

        init: function () {
          const el = this.el;

          // Wait for the video to load
          el.addEventListener("materialtextureloaded", () => {
            const mesh = el.getObject3D("mesh");
            if (mesh && mesh.material) {
              const material = mesh.material;

              // Create custom shader material for chroma key with optional background masking
              const vertexShader = `
                varying vec2 vUv;
                void main() {
                  vUv = uv;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `;

              const fragmentShader = `
                uniform sampler2D map;
                uniform vec3 chromaColor;
                uniform float threshold;
                uniform float smoothing;
                uniform float opacity;
                uniform bool backgroundMask;
                uniform float bgScaleX;
                uniform float bgScaleY;
                varying vec2 vUv;

                void main() {
                  vec4 textureColor = texture2D(map, vUv);

                  // Chroma key transparency - hard cutoff for complete transparency
                  float distance = length(textureColor.rgb - chromaColor);
                  float chromaAlpha = distance > threshold ? 1.0 : 0.0;

                  // Optional background masking - only appear over background bounds
                  float bgAlpha = 1.0;
                  if (backgroundMask) {
                    // Convert UV to normalized device coordinates centered at 0,0
                    vec2 ndc = (vUv - 0.5) * 2.0;

                    // Check if within background image bounds
                    float bgHalfWidth = bgScaleX / 2.0;
                    float bgHalfHeight = bgScaleY / 2.0;

                    // Fade out smoothly at background edges
                    float fadeZone = 0.1;
                    float distFromEdgeX = bgHalfWidth - abs(ndc.x);
                    float distFromEdgeY = bgHalfHeight - abs(ndc.y);

                    float alphaX = smoothstep(-fadeZone, fadeZone, distFromEdgeX);
                    float alphaY = smoothstep(-fadeZone, fadeZone, distFromEdgeY);

                    bgAlpha = alphaX * alphaY;
                  }

                  float finalAlpha = chromaAlpha * bgAlpha;
                  gl_FragColor = vec4(textureColor.rgb, textureColor.a * finalAlpha * opacity);
                }
              `;

              const combinedMaterial = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: {
                  map: { value: material.map },
                  chromaColor: { value: new THREE.Color(this.data.color) },
                  threshold: { value: this.data.threshold },
                  smoothing: { value: this.data.smoothing },
                  opacity: { value: material.opacity || 1.0 },
                  backgroundMask: { value: this.data.backgroundMask },
                  bgScaleX: { value: this.data.bgScaleX },
                  bgScaleY: { value: this.data.bgScaleY },
                },
                transparent: true,
                side: THREE.DoubleSide,
              });

              mesh.material = combinedMaterial;
            }
          });
        },
      });

      // Depth-based parallax component for natural movement with stability improvements
      AFRAME.registerComponent("depth-parallax", {
        schema: {
          enabled: { type: "boolean", default: true },
          baseDepth: { type: "number", default: 0 }, // Reference depth (0 = no parallax)
          depthScale: { type: "number", default: 0.3 }, // How much depth affects movement
          smoothing: { type: "number", default: 0.85 }, // Movement smoothing
          maxDistance: { type: "number", default: 2.0 }, // Maximum effective distance
          adaptiveSmoothing: { type: "boolean", default: true }, // Enable distance-based smoothing
        },

        init: function () {
          this.targetEntity = this.el.sceneEl.querySelector(
            "[mindar-image-target]"
          );
          this.previousPosition = new THREE.Vector3();
          this.previousRotation = new THREE.Euler();
          this.basePosition = new THREE.Vector3();
          this.baseRotation = new THREE.Euler();
          this.isInitialized = false;
          this.trackingQuality = 1.0;
          this.frameCount = 0;
        },

        tick: function () {
          if (!this.data.enabled || !this.targetEntity) return;

          const targetObject3D = this.targetEntity.object3D;
          const myObject3D = this.el.object3D;
          this.frameCount++;

          // Initialize base position on first frame
          if (!this.isInitialized) {
            this.basePosition.copy(myObject3D.position);
            this.baseRotation.copy(myObject3D.rotation);
            this.previousPosition.copy(myObject3D.position);
            this.previousRotation.copy(myObject3D.rotation);
            this.isInitialized = true;
            return;
          }

          // Estimate distance to target based on scale changes
          const currentScale = targetObject3D.scale.length();
          const estimatedDistance = Math.min(this.data.maxDistance, Math.max(0.1, 1.0 / Math.max(0.1, currentScale - 1.0)));
          
          // Calculate adaptive smoothing based on distance and tracking quality
          let adaptiveSmoothing = this.data.smoothing;
          if (this.data.adaptiveSmoothing) {
            // Increase smoothing when very close (< 0.5 units) or tracking quality is poor
            const distanceFactor = Math.max(0.0, Math.min(1.0, (estimatedDistance - 0.2) / 0.8));
            const qualityFactor = Math.max(0.3, this.trackingQuality);
            adaptiveSmoothing = Math.min(0.95, this.data.smoothing + (1 - distanceFactor) * 0.1 + (1 - qualityFactor) * 0.05);
          }

          // Calculate parallax factor based on Z-depth with distance dampening
          const depth = this.basePosition.z;
          const baseParallaxFactor = 1.0 - depth * this.data.depthScale;
          
          // Reduce parallax effect when very close to prevent wobbling
          const distanceDampening = Math.max(0.2, Math.min(1.0, estimatedDistance / 0.8));
          const parallaxFactor = baseParallaxFactor * distanceDampening;

          // Get target movement (relative to base position)
          const targetPos = new THREE.Vector3();
          targetPos.copy(this.basePosition);

          // Apply parallax scaling to target movement with stability constraints
          const targetMovement = new THREE.Vector3();
          targetMovement.copy(targetObject3D.position);
          
          // Clamp movement to prevent extreme positions
          targetMovement.x = Math.max(-0.5, Math.min(0.5, targetMovement.x));
          targetMovement.y = Math.max(-0.5, Math.min(0.5, targetMovement.y));
          
          targetMovement.multiplyScalar(parallaxFactor);
          targetPos.add(targetMovement);

          // Apply parallax scaling to rotation with dampening
          const targetRot = new THREE.Euler();
          targetRot.copy(this.baseRotation);
          const rotationDampening = Math.max(0.1, distanceDampening);
          targetRot.x += targetObject3D.rotation.x * parallaxFactor * rotationDampening;
          targetRot.y += targetObject3D.rotation.y * parallaxFactor * rotationDampening;
          targetRot.z += targetObject3D.rotation.z * parallaxFactor * rotationDampening;

          // Smooth interpolation to target with adaptive smoothing
          const lerpFactor = 1 - adaptiveSmoothing;
          this.previousPosition.lerp(targetPos, lerpFactor);
          this.previousRotation.x += (targetRot.x - this.previousRotation.x) * lerpFactor;
          this.previousRotation.y += (targetRot.y - this.previousRotation.y) * lerpFactor;
          this.previousRotation.z += (targetRot.z - this.previousRotation.z) * lerpFactor;

          // Apply smoothed values
          myObject3D.position.copy(this.previousPosition);
          myObject3D.rotation.copy(this.previousRotation);

          // Update tracking quality estimation every 30 frames
          if (this.frameCount % 30 === 0) {
            this.updateTrackingQuality(targetObject3D);
          }
        },

        updateTrackingQuality: function(targetObject3D) {
          // Simple tracking quality estimation based on movement stability
          const currentPos = targetObject3D.position;
          if (this.lastTrackedPosition) {
            const movement = currentPos.distanceTo(this.lastTrackedPosition);
            // Lower movement = better tracking quality
            this.trackingQuality = Math.max(0.1, Math.min(1.0, 1.0 - movement * 10));
          }
          this.lastTrackedPosition = currentPos.clone();
        },
      });

      // Distance-based position locking system - prevents wobble by locking position when too close
      AFRAME.registerComponent("tracking-stabilizer", {
        schema: {
          enabled: { type: "boolean", default: true },
          lockDistance: { type: "number", default: 0.6 }, // Distance below which to lock position
          lockTransitionZone: { type: "number", default: 0.2 }, // Smooth transition zone
          consistencyFrames: { type: "number", default: 5 }, // Frames to check for consistency
          maxJumpDistance: { type: "number", default: 0.05 }, // Max allowed position jump per frame
          stabilityMemory: { type: "number", default: 30 }, // Frames to remember stable positions
        },

        init: function () {
          this.isInitialized = false;
          this.lockedPosition = new THREE.Vector3();
          this.lockedRotation = new THREE.Euler();
          this.lastValidPosition = new THREE.Vector3();
          this.lastValidRotation = new THREE.Euler();
          this.isLocked = false;
          this.lockStartTime = 0;
          
          // Consistency tracking
          this.positionHistory = [];
          this.rotationHistory = [];
          this.stablePositions = [];
          this.frameCount = 0;
          
          // Distance tracking
          this.distanceHistory = [];
          this.currentDistance = 1.0;
        },

        tick: function () {
          if (!this.data.enabled) return;

          const object3D = this.el.object3D;
          this.frameCount++;

          if (!this.isInitialized) {
            this.lockedPosition.copy(object3D.position);
            this.lockedRotation.copy(object3D.rotation);
            this.lastValidPosition.copy(object3D.position);
            this.lastValidRotation.copy(object3D.rotation);
            this.isInitialized = true;
            return;
          }

          // Estimate distance based on scale changes
          const currentScale = object3D.scale.length();
          const normalizedScale = Math.max(0.1, Math.min(5.0, currentScale));
          this.currentDistance = Math.max(0.2, Math.min(3.0, 1.0 / Math.max(0.5, normalizedScale - 0.5)));
          
          // Track distance history for stability
          this.distanceHistory.push(this.currentDistance);
          if (this.distanceHistory.length > 10) {
            this.distanceHistory.shift();
          }
          
          // Calculate average distance for stability
          const avgDistance = this.distanceHistory.reduce((a, b) => a + b, 0) / this.distanceHistory.length;
          
          // Determine if we should be locked based on distance
          const shouldLock = avgDistance < this.data.lockDistance;
          const transitionFactor = Math.max(0, Math.min(1, 
            (avgDistance - (this.data.lockDistance - this.data.lockTransitionZone)) / this.data.lockTransitionZone
          ));

          // Track position history for consistency checking
          this.positionHistory.push({
            position: object3D.position.clone(),
            rotation: object3D.rotation.clone(),
            time: this.frameCount
          });
          
          if (this.positionHistory.length > this.data.consistencyFrames) {
            this.positionHistory.shift();
          }

          // Check for erratic movement (sudden jumps that indicate tracking instability)
          let isErratic = false;
          if (this.positionHistory.length >= 2) {
            const latest = this.positionHistory[this.positionHistory.length - 1];
            const previous = this.positionHistory[this.positionHistory.length - 2];
            const jumpDistance = latest.position.distanceTo(previous.position);
            
            if (jumpDistance > this.data.maxJumpDistance) {
              isErratic = true;
            }
          }

          // Determine final position based on locking logic
          let finalPosition = new THREE.Vector3();
          let finalRotation = new THREE.Euler();

          if (shouldLock || isErratic) {
            // Use locked position when too close or tracking is erratic
            if (!this.isLocked) {
              // Just entered lock mode - save current stable position
              this.lockedPosition.copy(this.lastValidPosition);
              this.lockedRotation.copy(this.lastValidRotation);
              this.isLocked = true;
              this.lockStartTime = this.frameCount;
            }
            
            // Use locked position with slight drift allowance for natural feel
            finalPosition.copy(this.lockedPosition);
            finalRotation.copy(this.lockedRotation);
            
            // Allow very small movements for natural micro-motion
            if (!isErratic && this.positionHistory.length > 0) {
              const current = this.positionHistory[this.positionHistory.length - 1];
              const microMovement = new THREE.Vector3().subVectors(current.position, this.lockedPosition);
              microMovement.multiplyScalar(0.02); // Only 2% of movement
              finalPosition.add(microMovement);
            }
            
          } else {
            // Normal tracking mode - use current position but with consistency checking
            this.isLocked = false;
            
            if (isErratic) {
              // Reject erratic movement, use last valid position
              finalPosition.copy(this.lastValidPosition);
              finalRotation.copy(this.lastValidRotation);
            } else {
              // Use current position and update last valid
              finalPosition.copy(object3D.position);
              finalRotation.copy(object3D.rotation);
              this.lastValidPosition.copy(finalPosition);
              this.lastValidRotation.copy(finalRotation);
              
              // Store stable positions for future reference
              this.stablePositions.push({
                position: finalPosition.clone(),
                rotation: finalRotation.clone(),
                distance: avgDistance,
                time: this.frameCount
              });
              
              if (this.stablePositions.length > this.data.stabilityMemory) {
                this.stablePositions.shift();
              }
            }
          }

          // Apply smooth transition when entering/exiting lock mode
          if (transitionFactor < 1.0 && transitionFactor > 0.0) {
            const currentPos = object3D.position.clone();
            const currentRot = object3D.rotation.clone();
            
            finalPosition.lerp(currentPos, transitionFactor);
            finalRotation.x = this.lerp(finalRotation.x, currentRot.x, transitionFactor);
            finalRotation.y = this.lerp(finalRotation.y, currentRot.y, transitionFactor);
            finalRotation.z = this.lerp(finalRotation.z, currentRot.z, transitionFactor);
          }

          // Apply final position
          object3D.position.copy(finalPosition);
          object3D.rotation.copy(finalRotation);
        },

        lerp: function(a, b, t) {
          return a + (b - a) * t;
        },
      });

      // Adaptive low-pass filter - lighter at distance, stronger when close
      AFRAME.registerComponent("low-pass-filter", {
        schema: {
          enabled: { type: "boolean", default: true },
          baseCutoffFrequency: { type: "number", default: 8.0 }, // Hz at normal distance - much higher/lighter
          minCutoffFrequency: { type: "number", default: 2.0 }, // Hz when very close - stronger filtering
          positionOnly: { type: "boolean", default: false }, // Apply only to position
        },

        init: function () {
          this.previousPosition = new THREE.Vector3();
          this.previousRotation = new THREE.Euler();
          this.filteredPosition = new THREE.Vector3();
          this.filteredRotation = new THREE.Euler();
          this.isInitialized = false;
          this.lastTime = 0;
        },

        tick: function (time) {
          if (!this.data.enabled) return;

          const object3D = this.el.object3D;
          const deltaTime = this.lastTime > 0 ? (time - this.lastTime) / 1000.0 : 0.016; // Default to 60fps
          this.lastTime = time;

          if (!this.isInitialized) {
            this.filteredPosition.copy(object3D.position);
            this.filteredRotation.copy(object3D.rotation);
            this.previousPosition.copy(object3D.position);
            this.previousRotation.copy(object3D.rotation);
            this.isInitialized = true;
            return;
          }

          // Estimate distance based on scale (rough approximation)
          const currentScale = object3D.scale.length();
          const normalizedScale = Math.max(0.1, Math.min(3.0, currentScale));
          const estimatedDistance = Math.max(0.3, Math.min(2.0, 1.0 / normalizedScale));
          
          // Calculate closeness factor (0 = far, 1 = very close)
          const closenessFactor = Math.max(0, Math.min(1, (1.0 - estimatedDistance) / 0.7));
          
          // Adapt cutoff frequency based on distance
          const adaptiveCutoff = this.data.baseCutoffFrequency - (this.data.baseCutoffFrequency - this.data.minCutoffFrequency) * closenessFactor;
          const rc = 1.0 / (2.0 * Math.PI * adaptiveCutoff);

          // Calculate filter coefficient for this frame
          const alpha = deltaTime / (rc + deltaTime);

          // Apply low-pass filter to position
          this.filteredPosition.x += alpha * (object3D.position.x - this.filteredPosition.x);
          this.filteredPosition.y += alpha * (object3D.position.y - this.filteredPosition.y);
          this.filteredPosition.z += alpha * (object3D.position.z - this.filteredPosition.z);

          // Apply low-pass filter to rotation (if not position-only)
          if (!this.data.positionOnly) {
            this.filteredRotation.x += alpha * (object3D.rotation.x - this.filteredRotation.x);
            this.filteredRotation.y += alpha * (object3D.rotation.y - this.filteredRotation.y);
            this.filteredRotation.z += alpha * (object3D.rotation.z - this.filteredRotation.z);
          }

          // Apply filtered values back to object
          object3D.position.copy(this.filteredPosition);
          if (!this.data.positionOnly) {
            object3D.rotation.copy(this.filteredRotation);
          }
        },
      });

      // Physics-based stabilization - AR elements have mass and resist sudden movements
      AFRAME.registerComponent("physics-stabilization", {
        schema: {
          enabled: { type: "boolean", default: true },
          mass: { type: "number", default: 1.0 }, // Higher mass = more resistance to movement
          friction: { type: "number", default: 0.8 }, // Energy loss per frame
          maxForce: { type: "number", default: 0.05 }, // Maximum force that can be applied
          springConstant: { type: "number", default: 0.3 }, // Spring force toward target
        },

        init: function () {
          this.velocity = new THREE.Vector3(0, 0, 0);
          this.angularVelocity = new THREE.Euler(0, 0, 0);
          this.targetPosition = new THREE.Vector3();
          this.targetRotation = new THREE.Euler();
          this.currentPosition = new THREE.Vector3();
          this.currentRotation = new THREE.Euler();
          this.isInitialized = false;
        },

        tick: function (time, timeDelta) {
          if (!this.data.enabled) return;

          const object3D = this.el.object3D;
          const dt = Math.min(timeDelta / 1000.0, 0.033); // Cap at 30fps for stability

          if (!this.isInitialized) {
            this.currentPosition.copy(object3D.position);
            this.currentRotation.copy(object3D.rotation);
            this.targetPosition.copy(object3D.position);
            this.targetRotation.copy(object3D.rotation);
            this.isInitialized = true;
            return;
          }

          // Update target from tracking
          this.targetPosition.copy(object3D.position);
          this.targetRotation.copy(object3D.rotation);

          // Calculate spring force toward target
          const force = new THREE.Vector3()
            .subVectors(this.targetPosition, this.currentPosition)
            .multiplyScalar(this.data.springConstant);

          // Limit maximum force to prevent violent movements
          if (force.length() > this.data.maxForce) {
            force.normalize().multiplyScalar(this.data.maxForce);
          }

          // Apply force to velocity (F = ma, so a = F/m)
          const acceleration = force.clone().divideScalar(this.data.mass);
          this.velocity.add(acceleration.multiplyScalar(dt));

          // Apply friction
          this.velocity.multiplyScalar(Math.pow(this.data.friction, dt));

          // Update position based on velocity
          this.currentPosition.add(this.velocity.clone().multiplyScalar(dt));

          // Simple rotation physics (could be improved)
          const angularForce = new THREE.Euler(
            (this.targetRotation.x - this.currentRotation.x) * this.data.springConstant,
            (this.targetRotation.y - this.currentRotation.y) * this.data.springConstant,
            (this.targetRotation.z - this.currentRotation.z) * this.data.springConstant
          );

          this.angularVelocity.x += angularForce.x * dt / this.data.mass;
          this.angularVelocity.y += angularForce.y * dt / this.data.mass;
          this.angularVelocity.z += angularForce.z * dt / this.data.mass;

          // Apply angular friction
          this.angularVelocity.x *= Math.pow(this.data.friction, dt);
          this.angularVelocity.y *= Math.pow(this.data.friction, dt);
          this.angularVelocity.z *= Math.pow(this.data.friction, dt);

          // Update rotation
          this.currentRotation.x += this.angularVelocity.x * dt;
          this.currentRotation.y += this.angularVelocity.y * dt;
          this.currentRotation.z += this.angularVelocity.z * dt;

          // Apply physics-based position back to object
          object3D.position.copy(this.currentPosition);
          object3D.rotation.copy(this.currentRotation);
        },
      });

      // ========================================
      // UTILITY FUNCTIONS
      // ========================================

      function isIOSDevice() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      }

      // Log device info for debugging
      console.log(
        `üîç Device info: iOS=${isIOSDevice()}, UserAgent=${navigator.userAgent}`
      );

      // Minimalistic audio button for when autoplay is blocked
      function addMinimalAudioButton() {
        // Check if button already exists
        if (document.getElementById("minimal-audio-btn")) return;

        const audioBtn = document.createElement("button");
        audioBtn.id = "minimal-audio-btn";
        audioBtn.innerHTML = "üîä";
        audioBtn.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: transparent;
          color: white;
          border: none;
          padding: 8px;
          border-radius: 50%;
          font-size: 20px;
          cursor: pointer;
          z-index: 1000;
          transition: opacity 0.3s ease;
          opacity: 0.8;
          text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
        `;

        audioBtn.addEventListener("click", () => {
          const ambientAudio = document.getElementById("ambient-audio");
          if (ambientAudio) {
            ambientAudio.volume = 0.3;
            ambientAudio
              .play()
              .then(() => {
                console.log("üéµ Audio enabled by user interaction");
                // Hide button after successful audio start
                audioBtn.style.opacity = "0";
                setTimeout(() => audioBtn.remove(), 300);
              })
              .catch(console.error);
          }
        });

        // Hover effect
        audioBtn.addEventListener("mouseenter", () => {
          audioBtn.style.opacity = "1";
        });
        audioBtn.addEventListener("mouseleave", () => {
          audioBtn.style.opacity = "0.8";
        });

        document.body.appendChild(audioBtn);
      }

      // Asset preloading function with iOS compatibility
      function preloadAsset(url, type) {
        return new Promise((resolve, reject) => {
          const cacheBuster = Date.now();
          const fullUrl = `${url}?v=${cacheBuster}`;
          const isIOS = isIOSDevice();

          // Set timeout to avoid hanging on iOS
          const timeout = setTimeout(
            () => {
              console.warn(`‚è∞ Preload timeout for ${type}: ${url}`);
              resolve(null); // Resolve with null instead of rejecting
            },
            isIOS ? 5000 : 10000
          ); // Shorter timeout on iOS

          if (type === "video") {
            const video = document.createElement("video");
            video.preload = isIOS ? "metadata" : "auto"; // Less aggressive preload on iOS
            video.muted = true;
            video.crossOrigin = "anonymous";
            video.playsInline = true; // Essential for iOS

            const onLoaded = () => {
              clearTimeout(timeout);
              console.log(`‚úÖ Preloaded video: ${url}`);
              resolve(video);
            };

            const onError = (e) => {
              clearTimeout(timeout);
              console.warn(`‚ö†Ô∏è Video preload failed (continuing): ${url}`, e);
              resolve(null); // Continue instead of failing
            };

            // Use single event listener for iOS compatibility
            if (isIOS) {
              video.addEventListener("loadedmetadata", onLoaded);
            } else {
              video.addEventListener("loadeddata", onLoaded);
            }
            video.addEventListener("error", onError);

            video.src = fullUrl;
          } else if (type === "audio") {
            const audio = document.createElement("audio");
            audio.preload = isIOS ? "metadata" : "auto";
            audio.crossOrigin = "anonymous";

            const onLoaded = () => {
              clearTimeout(timeout);
              console.log(`‚úÖ Preloaded audio: ${url}`);
              resolve(audio);
            };

            const onError = (e) => {
              clearTimeout(timeout);
              console.warn(`‚ö†Ô∏è Audio preload failed (continuing): ${url}`, e);
              resolve(null);
            };

            audio.addEventListener("loadedmetadata", onLoaded);
            audio.addEventListener("error", onError);

            audio.src = fullUrl;
          } else {
            // Image preloading
            const img = new Image();
            img.crossOrigin = "anonymous";

            img.onload = () => {
              clearTimeout(timeout);
              console.log(`‚úÖ Preloaded image: ${url}`);
              resolve(img);
            };

            img.onerror = (e) => {
              clearTimeout(timeout);
              console.warn(`‚ö†Ô∏è Image preload failed (continuing): ${url}`, e);
              resolve(null);
            };

            img.src = fullUrl;
          }
        });
      }

      // ========================================
      // MAIN APPLICATION FUNCTIONS
      // ========================================

      // Main AR experience loader
      async function loadARExperience() {
        try {
          console.log("üöÄ Starting AR experience...");

          // Create cache-busting timestamp
          const cacheBuster = Date.now();

          // Load manifest with cache busting
          const response = await fetch(`./manifest.json?v=${cacheBuster}`);
          if (!response.ok) {
            throw new Error(`Failed to load manifest: ${response.status}`);
          }
          const manifest = await response.json();
          console.log("üìÑ Loaded manifest:", manifest.title);

          // Update page title and about link
          document.title = `${manifest.title} - AR Experience`;
          const aboutLink = document.getElementById("about-link");
          if (manifest.aboutLink) {
            aboutLink.href = manifest.aboutLink;
          }
          // Footer is always visible now - no need to remove hidden class

          // Update loading text to show preloading
          const loadingEl = document.getElementById("loading");
          loadingEl.innerHTML =
            "<h3>Loading AR Experience...</h3><p>Preloading assets...</p>";

          // Preload all assets with iOS-friendly approach
          console.log("üì¶ Preloading all assets...");
          const isIOS = isIOSDevice();

          const preloadPromises = manifest.overlays
            .map(async (overlay) => {
              if (overlay.url.mp4 || overlay.url.webm) {
                let baseVideoUrl = overlay.url.mp4 || overlay.url.webm;
                console.log(`üé• Preloading video: ${baseVideoUrl}`);
                return preloadAsset(baseVideoUrl, "video");
              } else {
                const imageUrl =
                  overlay.url.png ||
                  overlay.url.jpg ||
                  overlay.url.gif ||
                  overlay.url.webp;
                if (imageUrl) {
                  console.log(`üñºÔ∏è Preloading image: ${imageUrl}`);
                  return preloadAsset(imageUrl, "image");
                }
              }
            })
            .filter(Boolean);

          // Wait for all assets with global timeout for iOS
          try {
            if (isIOS) {
              // Shorter timeout for iOS to prevent hanging
              await Promise.race([
                Promise.all(preloadPromises),
                new Promise((resolve) =>
                  setTimeout(() => {
                    console.log(
                      "üì± iOS: Continuing with partial asset loading..."
                    );
                    resolve();
                  }, 8000)
                ),
              ]);
            } else {
              await Promise.all(preloadPromises);
            }
            console.log("‚úÖ Asset preloading completed!");
          } catch (error) {
            console.warn(
              "‚ö†Ô∏è Some assets failed to preload, continuing...",
              error
            );
          }

          // Update loading text
          loadingEl.innerHTML =
            "<h3>Loading AR Experience...</h3><p>Creating AR scene...</p>";

          // Get references
          const assetsEl = document.getElementById("assets");
          const targetRoot = document.getElementById("target-root");

          // Create assets and overlays
          manifest.overlays.forEach((overlay, index) => {
            try {
              // Create asset
              let assetEl;
              const assetId = `asset-${overlay.id}`;

              if (overlay.url.mp4 || overlay.url.webm) {
                // Simple video asset creation - no fallbacks for debugging
                let finalUrl = overlay.url.mp4 || overlay.url.webm;

                console.log(
                  `üé• Creating video asset for ${overlay.id}: ${finalUrl}`
                );

                // Create video element
                assetEl = document.createElement("video");
                assetEl.src = `${finalUrl}?v=${cacheBuster}`;
                assetEl.setAttribute("autoplay", "false"); // Don't autoplay, we'll control this
                assetEl.setAttribute("loop", "true");
                assetEl.setAttribute("muted", "true");
                assetEl.setAttribute("playsinline", "true");
                assetEl.setAttribute("crossorigin", "anonymous");
                assetEl.setAttribute("preload", "auto"); // Preload full video for better sync

                // Simplified video event listeners
                assetEl.addEventListener("loadeddata", () => {
                  console.log(`‚úÖ Video loaded: ${overlay.id}`);
                });
                assetEl.addEventListener("canplay", () => {
                  console.log(`üé¨ Video ready: ${overlay.id}`);
                  assetEl.play().catch((error) => {
                    console.warn(`‚ö†Ô∏è Autoplay prevented: ${overlay.id}`, error);
                  });
                });
                assetEl.addEventListener("error", (e) => {
                  console.error(`‚ùå Video error: ${overlay.id}`, e);
                });
              } else {
                // Image asset creation
                console.log(`üñºÔ∏è Creating image asset for ${overlay.id}`);
                assetEl = document.createElement("img");
                const imageUrl =
                  overlay.url.png ||
                  overlay.url.jpg ||
                  overlay.url.gif ||
                  overlay.url.webp;

                if (!imageUrl) {
                  console.warn(
                    `‚ö†Ô∏è No supported image format for: ${overlay.id}`
                  );
                  return;
                }

                assetEl.src = `${imageUrl}?v=${cacheBuster}`;
                assetEl.setAttribute("crossorigin", "anonymous");

                // Image event listeners
                assetEl.addEventListener("load", () => {
                  console.log(`‚úÖ Image loaded: ${overlay.id}`);
                });
                assetEl.addEventListener("error", (e) => {
                  console.error(`‚ùå Image error: ${overlay.id}`, e);
                });
              }

              assetEl.id = assetId;
              assetsEl.appendChild(assetEl);

              // Simple AR element creation - no complex fallbacks for debugging
              const mediaEl = document.createElement(
                overlay.url.mp4 || overlay.url.webm ? "a-video" : "a-image"
              );
              mediaEl.setAttribute("id", overlay.id);
              mediaEl.setAttribute("src", `#${assetId}`);
              mediaEl.setAttribute("position", overlay.position.join(" "));
              mediaEl.setAttribute("scale", overlay.scale.join(" "));
              mediaEl.setAttribute("geometry", "primitive: plane");

              if (overlay.url.mp4 || overlay.url.webm) {
                // Video configuration map for chroma key settings
                const videoConfig = {
                  "bush-video": {
                    chromaType: "magenta",
                    color: "#FF00FF", // Pure magenta
                    threshold: 0.7, // Higher threshold to remove more magenta
                    smoothing: 0, // Sharp edges
                    maskToBg: false, // Bush appears in foreground
                  },
                  "title-video": {
                    chromaType: "magenta",
                    color: "#FF00FF", // Pure magenta
                    threshold: 0.7, // Higher threshold to remove more magenta
                    smoothing: 0, // Sharp edges
                    maskToBg: false, // Title appears over everything
                  },
                  "clouds-video": {
                    chromaType: "magenta",
                    color: "#FF00FF", // Pure magenta
                    threshold: 0.7, // Higher threshold to remove more magenta
                    smoothing: 0, // Sharp edges
                    depthMask: false, // Remove depth masking - use background masking instead
                    backgroundMask: true, // Only appear over background image
                  },
                };

                const config = videoConfig[overlay.id];

                if (config) {
                  // Video with chroma key transparency
                  console.log(
                    `üé¨ Creating ${config.chromaType} chroma key video element for ${overlay.id} with threshold: ${config.threshold}`
                  );
                  mediaEl.setAttribute(
                    "material",
                    `transparent: true; opacity: ${
                      overlay.opacity || 1.0
                    }; alphaTest: 0.1; shader: flat`
                  );

                  // Apply chroma key with optional background masking
                  const chromaKeyAttrs = `color: ${config.color}; threshold: ${config.threshold}; smoothing: ${config.smoothing}`;
                  if (config.backgroundMask) {
                    console.log(
                      `üé≠ Applying background mask to ${overlay.id} - only appear over background image`
                    );
                    mediaEl.setAttribute(
                      "chroma-key",
                      `${chromaKeyAttrs}; backgroundMask: true; bgScaleX: 1.1625; bgScaleY: 1.5`
                    );
                  } else {
                    mediaEl.setAttribute("chroma-key", chromaKeyAttrs);
                  }
                } else {
                  // Video element with basic transparency (for non-chroma backgrounds)
                  console.log(
                    `üé• Creating standard video element for ${overlay.id}`
                  );
                  mediaEl.setAttribute(
                    "material",
                    `transparent: true; opacity: ${
                      overlay.opacity || 1.0
                    }; alphaTest: 0.1; shader: flat`
                  );
                }
                mediaEl.setAttribute("autoplay", "true");
                mediaEl.setAttribute("loop", "true");
              } else {
                // Image element
                mediaEl.setAttribute(
                  "material",
                  `transparent: true; opacity: ${overlay.opacity || 1.0}`
                );
                console.log(`üñºÔ∏è Creating image element for ${overlay.id}`);
              }

              // Add simplified depth-based parallax - let the tracking stabilizer handle stability
              const zPos = overlay.position[2];
              mediaEl.setAttribute(
                "depth-parallax",
                `enabled: true; baseDepth: ${zPos}; depthScale: 0.25; smoothing: 0.85; maxDistance: 2.0; adaptiveSmoothing: false`
              );

              // Add physics-based stabilization for natural movement
              mediaEl.setAttribute(
                "physics-stabilization",
                `enabled: true; mass: 2.0; friction: 0.85; maxForce: 0.02; springConstant: 0.25`
              );

              // Start invisible to prevent black frames during loading
              mediaEl.setAttribute("visible", "false");

              targetRoot.appendChild(mediaEl);
              console.log(
                `‚úÖ Added overlay: ${overlay.id} with depth parallax`
              );
            } catch (error) {
              console.error(
                `‚ùå Failed to create overlay ${overlay.id}:`,
                error
              );
            }
          });

          // Wait for all videos to be ready before showing the scene
          const waitForAllVideosReady = async () => {
            const videos = document.querySelectorAll("video");
            const videoPromises = Array.from(videos).map((video) => {
              return new Promise((resolve) => {
                if (video.readyState >= 3) {
                  // HAVE_FUTURE_DATA
                  resolve();
                } else {
                  const onReady = () => {
                    video.removeEventListener("canplay", onReady);
                    video.removeEventListener("loadeddata", onReady);
                    resolve();
                  };
                  video.addEventListener("canplay", onReady);
                  video.addEventListener("loadeddata", onReady);

                  // Fallback timeout
                  setTimeout(resolve, 3000);
                }
              });
            });

            try {
              await Promise.all(videoPromises);
              console.log("üé¨ All videos ready!");
            } catch (error) {
              console.warn("‚ö†Ô∏è Some videos not ready, continuing...", error);
            }

            // Get all AR elements for final reveal
            const arElements = targetRoot.querySelectorAll("a-video, a-image");

            // Start all videos simultaneously
            const startPromises = Array.from(videos).map((video) => {
              return video.play().catch((error) => {
                console.warn("‚ö†Ô∏è Could not start video:", video.id, error);
              });
            });

            await Promise.all(startPromises);

            // Small delay for synchronization, then show everything at once
            setTimeout(() => {
              arElements.forEach((el) => {
                el.setAttribute("visible", "true");
              });
              loadingEl.classList.add("hidden");

              // Start ambient audio when AR experience is ready
              const ambientAudio = document.getElementById("ambient-audio");
              if (ambientAudio) {
                ambientAudio.volume = 0.3; // Set volume to 30% for ambient background
                ambientAudio
                  .play()
                  .then(() => {
                    console.log("üéµ Ambient audio started successfully");
                  })
                  .catch((error) => {
                    console.log(
                      "üîá Audio autoplay prevented (user interaction required):",
                      error.message
                    );
                    // Show minimalistic audio button when autoplay is blocked
                    addMinimalAudioButton();
                  });
              }

              console.log("‚úÖ AR experience ready and synchronized!");
            }, 200);
          };

          // Initialize the synchronized experience
          waitForAllVideosReady();
        } catch (error) {
          console.error("‚ùå Failed to load AR experience:", error);
          document.getElementById("loading").classList.add("hidden");
          const errorEl = document.getElementById("error");
          errorEl.textContent = `Error: ${error.message}`;
          errorEl.classList.remove("hidden");
        }
      }

      // Auto-start AR when page loads
      document.addEventListener("DOMContentLoaded", () => {
        console.log("üì± DOM loaded, initializing AR...");

        // Add cache busting to target.mind file
        const scene = document.querySelector("a-scene");
        const cacheBuster = Date.now();
        const currentSrc = scene.getAttribute("mindar-image");
        const updatedSrc = currentSrc.replace(
          "./target.mind",
          `./target.mind?v=${cacheBuster}`
        );
        scene.setAttribute("mindar-image", updatedSrc);
        console.log("üéØ Target updated with cache buster");

        // Show loading immediately since autoStart is true
        document.getElementById("loading").classList.remove("hidden");

        // Wait for scene to load, then load AR content
        scene.addEventListener(
          "loaded",
          async () => {
            console.log("üé¨ Scene loaded, loading AR content...");

            // Small delay to ensure MindAR is initialized
            setTimeout(async () => {
              try {
                await loadARExperience();
              } catch (error) {
                console.error("‚ùå Failed to load AR:", error);
                document.getElementById("loading").classList.add("hidden");
                const errorEl = document.getElementById("error");
                errorEl.textContent = `Error: ${error.message}`;
                errorEl.classList.remove("hidden");
              }
            }, 2000);
          },
          { once: true }
        );
      });
    </script>
  </body>
</html>
