<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no, shrink-to-fit=no"
    />
    <script>
      // iOS detection function for optimal format serving
      function isIOSDevice() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      }

      // Function to get appropriate format for current device with APNG fallback
      function getOptimalUrl(webmUrl) {
        if (isIOSDevice()) {
          // For iOS: Try HEVC first, then APNG fallback, then WebM as last resort
          const hevcUrl = webmUrl.replace('.webm', '_hevc.mov').replace('.WEBM', '_hevc.mov');
          const apngUrl = webmUrl.replace('.webm', '_optimized.apng').replace('.WEBM', '_optimized.apng');
          
          console.log(`üì± iOS detected - Primary: ${hevcUrl}, Fallback: ${apngUrl}`);
          return { primary: hevcUrl, fallback: apngUrl, webm: webmUrl };
        } else {
          // For other devices, use WebM format
          console.log(`üíª Non-iOS device - using WebM format: ${webmUrl}`);
          return { primary: webmUrl, fallback: null, webm: webmUrl };
        }
      }

      // Enhanced asset preloading with fallback support
      async function preloadAssetWithFallback(urls, type) {
        // Try primary format first
        try {
          await preloadAsset(urls.primary, type);
          console.log(`‚úÖ Primary format loaded: ${urls.primary}`);
          return urls.primary;
        } catch (error) {
          console.log(`‚ùå Primary format failed: ${error.message}`);
          
          // Try fallback format if available
          if (urls.fallback) {
            try {
              await preloadAsset(urls.fallback, type === 'video' ? 'image' : type);
              console.log(`‚úÖ Fallback format loaded: ${urls.fallback}`);
              return urls.fallback;
            } catch (fallbackError) {
              console.log(`‚ùå Fallback format failed: ${fallbackError.message}`);
            }
          }
          
          // Last resort: try WebM
          try {
            await preloadAsset(urls.webm, type);
            console.log(`‚úÖ WebM fallback loaded: ${urls.webm}`);
            return urls.webm;
          } catch (webmError) {
            console.error(`‚ùå All formats failed for asset`);
            throw webmError;
          }
        }
      }

      // Log device detection results
      console.log(`Device detection: iOS = ${isIOSDevice()}, UserAgent = ${navigator.userAgent}`);
    </script>
    <!-- Prevent caching for development -->
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <!-- Android-specific meta tags -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="theme-color" content="#000000" />
    <!-- Camera permissions hint -->
    <meta http-equiv="Permissions-Policy" content="camera=*" />
    <title>Paramo - AR Experience</title>
    <script src="https://cdn.jsdelivr.net/npm/aframe@1.6.0/dist/aframe-master.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        /* Hardware acceleration for smoother performance */
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
        /* Prevent text selection and touch interactions that could interfere */
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
        /* Ensure full viewport coverage */
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      a-scene {
        /* Ensure scene covers full viewport */
        width: 100% !important;
        height: 100% !important;
      }
      .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 1000;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 10px;
      }
      .error {
        position: fixed;
        top: 10px;
        left: 10px;
        right: 10px;
        background: #ff4444;
        color: white;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
      }
      .hidden {
        display: none;
      }
      .footer {
        position: fixed;
        bottom: 10px;
        left: 10px;
        right: 10px;
        text-align: center;
        z-index: 999;
      }
      .footer a {
        color: white;
        text-decoration: none;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 12px;
      }
      .start-button {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #4caf50;
        color: white;
        border: none;
        padding: 15px 30px;
        border-radius: 25px;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        z-index: 1000;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }
      .start-button:hover {
        background: #45a049;
      }

      /* Hide MindAR default UI elements */
      .mindar-ui-loading,
      .mindar-ui-scanning,
      .mindar-ui-error {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="loading" class="loading">
      <h2>Loading Paramo...</h2>
      <p>Point your camera at the target image</p>
    </div>

    <button id="start-button" class="start-button">Start AR Experience</button>

    <div id="error" class="error hidden"></div>

    <!-- Background water audio for iOS compatibility -->
    <audio id="water-audio" preload="none" muted>
      <source src="assets/water.mp3" type="audio/mpeg" />
      <source src="assets/water.ogg" type="audio/ogg" />
    </audio>

    <a-scene
      id="ar-scene"
      mindar-image="imageTargetSrc: ./target.mind; autoStart: false; uiLoading: yes; uiScanning: yes; uiError: yes; filterMinCF: 0.0001; filterBeta: 0.01; warmupTolerance: 5; missTolerance: 5"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
      renderer="alpha: true; antialias: true; colorManagement: true; physicallyCorrectLights: true; precision: highp; powerPreference: high-performance"
      style="position: fixed; top: 0; left: 0; width: 100%; height: 100%"
      embedded
    >
      <a-assets id="assets">
        <!-- Assets will be loaded dynamically -->
      </a-assets>

      <a-light type="ambient" color="#ffffff" intensity="0.6"></a-light>

      <a-entity
        id="target-root"
        mindar-image-target="targetIndex: 0"
        animation-mixer=""
        smooth="enabled: true; factor: 0.9"
      >
        <!-- AR content will be added here -->
      </a-entity>

      <a-camera
        position="0 0 0"
        look-controls="enabled: false"
        cursor="rayOrigin: mouse"
        wasd-controls="enabled: false"
      ></a-camera>
    </a-scene>

    <div class="footer hidden" id="footer">
      <a href="" id="about-link" target="_blank">About this artwork</a>
    </div>

    <script>
      // iOS detection function for video compatibility
      function isIOSDevice() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      }

      // Function to get appropriate video format for current device
      function getVideoUrl(webmUrl) {
        // Always use WebM for now until HEVC alpha support is confirmed
        // iOS will use chroma key for transparency
        console.log(`ÔøΩ Using WebM format with transparency handling: ${webmUrl}`);
        return webmUrl;
      }

      // Log device detection results
      console.log(`Device detection: iOS = ${isIOSDevice()}, UserAgent = ${navigator.userAgent}`);

      // Chroma key component for video transparency
      AFRAME.registerComponent("chroma-key", {
        schema: {
          color: { type: "color", default: "#000000" },
          threshold: { type: "number", default: 0.15 },
          smoothing: { type: "number", default: 0.1 },
        },

        init: function () {
          const el = this.el;

          // Wait for the video to load
          el.addEventListener("materialtextureloaded", () => {
            const mesh = el.getObject3D("mesh");
            if (mesh && mesh.material) {
              const material = mesh.material;

              // Create custom shader material for chroma key
              const vertexShader = `
                varying vec2 vUv;
                void main() {
                  vUv = uv;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `;

              const fragmentShader = `
                uniform sampler2D map;
                uniform vec3 chromaColor;
                uniform float threshold;
                uniform float smoothing;
                uniform float opacity;
                varying vec2 vUv;

                void main() {
                  vec4 textureColor = texture2D(map, vUv);
                  float distance = length(textureColor.rgb - chromaColor);
                  float alpha = smoothstep(threshold - smoothing, threshold + smoothing, distance);
                  gl_FragColor = vec4(textureColor.rgb, textureColor.a * alpha * opacity);
                }
              `;

              const chromaKeyMaterial = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: {
                  map: { value: material.map },
                  chromaColor: { value: new THREE.Color(this.data.color) },
                  threshold: { value: this.data.threshold },
                  smoothing: { value: this.data.smoothing },
                  opacity: { value: material.opacity || 1.0 },
                },
                transparent: true,
                side: THREE.DoubleSide,
              });

              mesh.material = chromaKeyMaterial;
            }
          });
        },
      });

      // Smoothing component for better tracking stability
      AFRAME.registerComponent("smooth", {
        schema: {
          enabled: { type: "boolean", default: true },
          factor: { type: "number", default: 0.9 },
        },

        init: function () {
          this.previousPosition = new THREE.Vector3();
          this.previousRotation = new THREE.Euler();
          this.targetPosition = new THREE.Vector3();
          this.targetRotation = new THREE.Euler();
        },

        tick: function () {
          if (!this.data.enabled) return;

          const el = this.el;
          const object3D = el.object3D;

          // Get current target position and rotation
          this.targetPosition.copy(object3D.position);
          this.targetRotation.copy(object3D.rotation);

          // Apply smoothing
          this.previousPosition.lerp(this.targetPosition, 1 - this.data.factor);
          this.previousRotation.x +=
            (this.targetRotation.x - this.previousRotation.x) *
            (1 - this.data.factor);
          this.previousRotation.y +=
            (this.targetRotation.y - this.previousRotation.y) *
            (1 - this.data.factor);
          this.previousRotation.z +=
            (this.targetRotation.z - this.previousRotation.z) *
            (1 - this.data.factor);

          // Apply smoothed values
          object3D.position.copy(this.previousPosition);
          object3D.rotation.copy(this.previousRotation);
        },
      });

      // Asset preloading function
      function preloadAsset(url, type) {
        return new Promise((resolve, reject) => {
          const cacheBuster = Date.now();
          const fullUrl = `${url}?v=${cacheBuster}`;

          if (type === "video") {
            const video = document.createElement("video");
            video.preload = "auto";
            video.muted = true;
            video.crossOrigin = "anonymous";

            const onLoaded = () => {
              console.log(`‚úÖ Preloaded video: ${url}`);
              resolve(video);
            };

            const onError = (e) => {
              console.error(`‚ùå Failed to preload video: ${url}`, e);
              reject(e);
            };

            video.addEventListener("loadeddata", onLoaded);
            video.addEventListener("canplaythrough", onLoaded);
            video.addEventListener("error", onError);

            video.src = fullUrl;
          } else if (type === "audio") {
            const audio = document.createElement("audio");
            audio.preload = "auto";
            audio.crossOrigin = "anonymous";

            const onLoaded = () => {
              console.log(`‚úÖ Preloaded audio: ${url}`);
              resolve(audio);
            };

            const onError = (e) => {
              console.error(`‚ùå Failed to preload audio: ${url}`, e);
              reject(e);
            };

            audio.addEventListener("loadeddata", onLoaded);
            audio.addEventListener("canplaythrough", onLoaded);
            audio.addEventListener("error", onError);

            audio.src = fullUrl;
          } else {
            // Image preloading
            const img = new Image();
            img.crossOrigin = "anonymous";

            img.onload = () => {
              console.log(`‚úÖ Preloaded image: ${url}`);
              resolve(img);
            };

            img.onerror = (e) => {
              console.error(`‚ùå Failed to preload image: ${url}`, e);
              reject(e);
            };

            img.src = fullUrl;
          }
        });
      }

      // Simple AR loader - reads manifest.json and creates AR experience
      async function loadARExperience() {
        try {
          console.log("üöÄ Starting AR experience...");

          // Create cache-busting timestamp
          const cacheBuster = Date.now();

          // Load manifest with cache busting
          const response = await fetch(`./manifest.json?v=${cacheBuster}`);
          if (!response.ok) {
            throw new Error(`Failed to load manifest: ${response.status}`);
          }
          const manifest = await response.json();
          console.log("üìÑ Loaded manifest:", manifest.title);

          // Update page title and about link
          document.title = `${manifest.title} - AR Experience`;
          if (manifest.aboutLink) {
            const aboutLink = document.getElementById("about-link");
            aboutLink.href = manifest.aboutLink;
            document.getElementById("footer").classList.remove("hidden");
          }

          // Update loading text to show preloading
          const loadingEl = document.getElementById("loading");
          loadingEl.innerHTML =
            "<h3>Loading AR Experience...</h3><p>Preloading assets...</p>";

          // Preload all assets first - simplified version for debugging
          console.log("üì¶ Preloading all assets...");
          const preloadPromises = manifest.overlays
            .map(async (overlay) => {
              if (overlay.url.mp4 || overlay.url.webm) {
                let baseVideoUrl = overlay.url.mp4 || overlay.url.webm;
                console.log(`üé• Preloading video: ${baseVideoUrl}`);
                return preloadAsset(baseVideoUrl, "video");
              } else {
                const imageUrl =
                  overlay.url.png ||
                  overlay.url.jpg ||
                  overlay.url.gif ||
                  overlay.url.webp;
                if (imageUrl) {
                  console.log(`üñºÔ∏è Preloading image: ${imageUrl}`);
                  return preloadAsset(imageUrl, "image");
                }
              }
            })
            .filter(Boolean);

          // Wait for all assets to be preloaded
          await Promise.all(preloadPromises);
          console.log("‚úÖ All assets preloaded successfully!");

          // Update loading text
          loadingEl.innerHTML =
            "<h3>Loading AR Experience...</h3><p>Creating AR scene...</p>";

          // Get references
          const assetsEl = document.getElementById("assets");
          const targetRoot = document.getElementById("target-root");
          const errorEl = document.getElementById("error");

          // Create assets and overlays
          manifest.overlays.forEach((overlay, index) => {
            try {
              // Create asset
              let assetEl;
              const assetId = `asset-${overlay.id}`;

              if (overlay.url.mp4 || overlay.url.webm) {
                // Simple video asset creation - no fallbacks for debugging
                let finalUrl = overlay.url.mp4 || overlay.url.webm;
                
                console.log(`üé• Creating video asset for ${overlay.id}: ${finalUrl}`);
                
                // Create video element
                assetEl = document.createElement("video");
                assetEl.src = `${finalUrl}?v=${cacheBuster}`;
                assetEl.setAttribute("autoplay", "true");
                assetEl.setAttribute("loop", "true");
                assetEl.setAttribute("muted", "true");
                assetEl.setAttribute("playsinline", "true");
                assetEl.setAttribute("crossorigin", "anonymous");
                assetEl.setAttribute("preload", "metadata");
                // Performance optimizations to reduce jitter
                assetEl.setAttribute("webkit-playsinline", "true");
                assetEl.setAttribute("x-webkit-airplay", "allow");
                // Optimize video for tracking stability
                assetEl.style.webkitTransform = "translate3d(0,0,0)"; // Force GPU acceleration
                assetEl.style.transform = "translate3d(0,0,0)";
                assetEl.style.webkitBackfaceVisibility = "hidden";
                assetEl.style.backfaceVisibility = "hidden";
                // Reduce video quality for better performance if needed
                assetEl.setAttribute("poster", ""); // No poster image to reduce load

                // Add video event listeners for debugging and optimization
                assetEl.addEventListener("loadedmetadata", () => {
                  console.log(`üìπ Video metadata loaded: ${overlay.id}`);
                  // Set video to lowest quality for better performance
                  if (assetEl.videoTracks && assetEl.videoTracks.length > 0) {
                    console.log(
                      `üé¨ Video track info:`,
                      assetEl.videoWidth,
                      "x",
                      assetEl.videoHeight
                    );
                  }
                });
                assetEl.addEventListener("loadeddata", () => {
                  console.log(`‚úÖ Video loaded successfully: ${overlay.id}`);
                });
                assetEl.addEventListener("canplay", () => {
                  console.log(`üé¨ Video can start playing: ${overlay.id}`);
                  // Explicitly play the video when it's ready
                  assetEl
                    .play()
                    .then(() => {
                      console.log(`‚ñ∂Ô∏è Video playing: ${overlay.id}`);
                    })
                    .catch((error) => {
                      console.warn(
                        `‚ö†Ô∏è Video autoplay prevented: ${overlay.id}`,
                        error
                      );
                    });
                });
                assetEl.addEventListener("error", (e) => {
                  console.error(`‚ùå Video error for ${overlay.id}:`, e);
                });
                assetEl.addEventListener("stalled", () => {
                  console.warn(`‚ö†Ô∏è Video stalled: ${overlay.id}`);
                });
              }

              assetEl.id = assetId;
              assetsEl.appendChild(assetEl);

              // Simple AR element creation - no complex fallbacks for debugging
              const mediaEl = document.createElement(overlay.url.mp4 || overlay.url.webm ? "a-video" : "a-image");
              mediaEl.setAttribute("id", overlay.id);
              mediaEl.setAttribute("src", `#${assetId}`);
              mediaEl.setAttribute("position", overlay.position.join(" "));
              mediaEl.setAttribute("scale", overlay.scale.join(" "));
              mediaEl.setAttribute("geometry", "primitive: plane");

              if (overlay.url.mp4 || overlay.url.webm) {
                // Video element with basic transparency
                mediaEl.setAttribute("material", `transparent: true; opacity: ${overlay.opacity || 1.0}; alphaTest: 0.1; shader: flat`);
                mediaEl.setAttribute("autoplay", "true");
                mediaEl.setAttribute("loop", "true");
                console.log(`ÔøΩ Creating video element for ${overlay.id}`);
              } else {
                // Image element
                mediaEl.setAttribute("material", `transparent: true; opacity: ${overlay.opacity || 1.0}`);
                console.log(`üñºÔ∏è Creating image element for ${overlay.id}`);
              }

              targetRoot.appendChild(mediaEl);
              console.log(`‚úÖ Added overlay: ${overlay.id}`);
            } catch (error) {
              console.error(
                `‚ùå Failed to create overlay ${overlay.id}:`,
                error
              );
            }
          });

          // Wait a moment for A-Frame to initialize
          setTimeout(() => {
            loadingEl.classList.add("hidden");
            console.log("‚úÖ AR experience ready!");

            // Ensure all videos are playing
            const videos = document.querySelectorAll("video");
            videos.forEach((video) => {
              if (video.paused) {
                video
                  .play()
                  .then(() => {
                    console.log("üîÑ Started paused video:", video.id);
                  })
                  .catch((error) => {
                    console.warn("‚ö†Ô∏è Could not start video:", video.id, error);
                  });
              }
            });
          }, 1000);
        } catch (error) {
          console.error("‚ùå Failed to load AR experience:", error);
          document.getElementById("loading").classList.add("hidden");
          const errorEl = document.getElementById("error");
          errorEl.textContent = `Error: ${error.message}`;
          errorEl.classList.remove("hidden");
        }
      }

      // Start AR function with Android compatibility
      async function startAR() {
        try {
          console.log("ü§ñ Starting AR for Android...");

          // Hide start button, show loading
          document.getElementById("start-button").style.display = "none";
          document.getElementById("loading").classList.remove("hidden");

          // Check camera permissions
          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            try {
              // Request camera permission explicitly
              const stream = await navigator.mediaDevices.getUserMedia({
                video: true,
              });
              console.log("üìπ Camera permission granted");
              // Stop the stream immediately, MindAR will handle it
              stream.getTracks().forEach((track) => track.stop());
            } catch (permError) {
              throw new Error(
                "Camera permission denied. Please enable camera access and refresh."
              );
            }
          }

          // Start MindAR
          const arSystem =
            document.querySelector("a-scene").systems["mindar-image-system"];
          if (arSystem) {
            await arSystem.start();
            console.log("üéØ MindAR started successfully");
          }

          // Load AR content
          await loadARExperience();

          // Start background water sound (iOS compatible with extensive error handling)
          try {
            const waterAudio = document.getElementById("water-audio");
            if (waterAudio) {
              // iOS-specific preparation
              waterAudio.muted = false;
              waterAudio.volume = 0.3;
              waterAudio.loop = true;

              // Load the audio first
              waterAudio.load();

              // Wait for audio to be ready
              const tryPlayAudio = () => {
                if (waterAudio.readyState >= 2) {
                  // HAVE_CURRENT_DATA
                  const playPromise = waterAudio.play();
                  if (playPromise !== undefined) {
                    playPromise
                      .then(() => {
                        console.log("üåä Water sound started successfully");
                      })
                      .catch((error) => {
                        console.log(
                          "‚ÑπÔ∏è Audio blocked by browser policy (this is normal):",
                          error.name
                        );
                        // Don't retry automatically - just log it's blocked
                      });
                  }
                } else {
                  // Wait for audio to load
                  setTimeout(tryPlayAudio, 500);
                }
              };

              // Start trying to play
              tryPlayAudio();
            }
          } catch (audioError) {
            console.log(
              "‚ÑπÔ∏è Audio not available (this is fine):",
              audioError.name
            );
          }
        } catch (error) {
          console.error("‚ùå Failed to start AR:", error);
          document.getElementById("loading").classList.add("hidden");
          document.getElementById("start-button").style.display = "block";
          const errorEl = document.getElementById("error");
          errorEl.textContent = `Error: ${error.message}`;
          errorEl.classList.remove("hidden");
        }
      }

      // Start when page loads
      document.addEventListener("DOMContentLoaded", () => {
        console.log("üì± DOM loaded, setting up start button...");

        // Add cache busting to target.mind file
        const scene = document.querySelector("a-scene");
        const cacheBuster = Date.now();
        const currentSrc = scene.getAttribute("mindar-image");
        const updatedSrc = currentSrc.replace(
          "./target.mind",
          `./target.mind?v=${cacheBuster}`
        );
        scene.setAttribute("mindar-image", updatedSrc);
        console.log("üéØ Updated target with cache buster");

        document
          .getElementById("start-button")
          .addEventListener("click", startAR);
      });
    </script>
  </body>
</html>
